@online{RW2015b,
	author = {Raphael Reitzig and Sebastian Wild},
	title = {A Practical and Worst-Case Efficient Algorithm for Divisor Methods of Apportionment},
	journal = {ArXiv e-prints},
	archivePrefix = {arXiv},
	eprint = {1504.06475},
	%url = {http://arxiv.org/abs/1504.06475},
	year = {2015},
	month = {9},
  abstract = {Proportional apportionment is the problem of assigning seats to parties according to their relative share of votes. Divisor methods are the de-facto standard solution, used in many countries.

In recent literature, there are two algorithms that implement divisor methods: one by Cheng and Eppstein (ISAAC, 2014) has worst-case optimal running time but is complex, while the other (Pukelsheim, 2014) is relatively simple and fast in practice but does not offer worst-case guarantees.

We demonstrate that the former algorithm is much slower than the other in practice propose a novel algorithm that avoids the shortcomings of both. We investigate the running-time behavior of the three contenders in order to determine which is most useful in practice.},
  note = {We thank Chao Xu for pointing us towards the [work by Cheng and Eppstein](https://dx.doi.org/10.1007/978-3-319-13075-0_46) and noting that the problem of [envy-free stick-division](RW2015a) is related to proportional apportionment as discussed there. He also observed that our approach for cutting sticks -- the core ideas of which turned out to carry over to this article -- could be improved to run in linear 
time.

Furthermore, we owe thanks to an anonymous reviewer whose constructive feedback
sparked broad changes which have greatly improved the article over its first 
incarnation.},
  code = {https://github.com/reitzig/2015_apportionment},
  talk = {http://www.slideshare.net/rreitzig/practical-and-worstcase-efficient-apportionment}
}

@online{RW2015a,
  author    = {Raphael Reitzig and Sebastian Wild},
  title     = {Building Fences Straight and High: An Optimal Algorithm for Finding the Maximum Length You Can Cut k Times from Given Sticks},
  journal = {Algorithmica},
  archivePrefix = {arXiv},
  eprint    = {1502.04048},
  doi       = {10.1007/s00453-017-0392-3},
  %url       = {http://arxiv.org/abs/1502.04048},
  primaryClass = {cs.DS},
  year      = {2017},
  month     = {November},
  %version   = {v2},
  abstract  = {Segal-Halevi, Hassidim, and Aumann (AAMAS, 2015) propose the problem of cutting sticks so that at least k sticks have equal length and no other stick is longer. This allows for an envy-free allocation of sticks to k players, one each. The resulting number of sticks should also be minimal.

We analyze the structure of this problem and devise a linear-time algorithm for it.},
  note = {[Erel Segal-Halevi](http://cs.stackexchange.com/users/1342/)
posed the [original question](http://cs.stackexchange.com/q/30073) on Computer Science Stack Exchange.
Our approach is based on observations in the answers by
[Abhishek Bansal](http://cs.stackexchange.com/users/19311/),
[InstructedA](http://cs.stackexchange.com/users/20169/) and
[FrankW](http://cs.stackexchange.com/users/13022/).
Hence, even though the eventual algorithm and its presentation have been developed 
and refined offline with the use of a blackboard and lots of paper, 
the result has been the product of a small "crowd" collaboration made possible 
by the Stack Exchange platform.

We thank Chao Xu for pointing us towards the work by [Cheng and Eppstein](https://dx.doi.org/10.1007/978-3-319-13075-0_46) (which lead to [another article of ours](RW2015b)), 
and for providing the observation we utilize in Section&nbsp;4.1.}
}

@INPROCEEDINGS{WNRL2013,
  author = {Sebastian Wild and Markus E. Nebel and Raphael Reitzig and Ulrich Laube},
  title = {Engineering Java 7's Dual Pivot Quicksort Using MaLiJan},
  booktitle = {Meeting on Algorithm Engineering \& Experiments (ALENEX)},
  organization = {SIAM},
  year = {2013},
  month = {January},
  url = {http://knowledgecenter.siam.org/0238-000024/0238-000024/1},
  pdf = {http://wwwagak.cs.uni-kl.de/Veroffentlichungen/Papers/dual-pivot-qs-engineering.pdf.html},
  doi = {10.1137/1.9781611972931.5},
  abstract = {Recent results on Java 7’s dual pivot Quicksort have revealed
    its highly asymmetric nature. These insights suggest that
    asymmetric pivot choices are preferable to symmetric ones
    for this Quicksort variant. From a theoretical point of view,
    this should allow us to improve on the current implementation
    in Oracle’s Java 7 runtime library. In this paper, we
    use our new tool MaLiJAn to confirm this asymptotically
    for combinatorial cost measures such as the total number of
    executed instructions. However, the observed running times
    show converse behavior. With the support of data provided
    by MaLiJAn we are able to identify the profiling capabilities
    of Oracle’s just-in-time compiler to be responsible for this
    unexpected outcome.
  },
  talk = {http://www.slideshare.net/sebawild/engineering-java-7s-dual-pivot-quicksort-using-malijan}
}

@mastersthesis{Reitzig2012,
  author = {Raphael Reitzig},
  title  = {Automated Parallelisation of Dynamic Programming Recursions},
  school = {University of Kaiserslautern},
  howpublished = {Master's thesis},
  year   = {2012},
  month  = {July},
  %url    = {http://reitzig.github.io/publications/Reitzig2012},
  abstract = {This thesis discusses whether and how dynamic programming recursions can be
    computed in parallel such that compilers can parallelise them automatically. We 
    discover that under certain assumptions which permit a rich class of dynamic 
    programming recursions, two kinds of recursions can be computed in parallel while 
    others can not. For those which can, we design and analyse efficient parallel algorithms 
    theoretically. We then implement several prototypes and investigate their performance
    empirically. Finally, we integrate automatic application of the developed algorithms 
    into a real-world compiler.
  },
  note = {  
   You can download all benchmark data that was used in the thesis
     [here](/assets/data/auto-parallel-dynprog_data.tar.gz).
   All code used in making the thesis is available on Github; there is one
   repository for the
     [Java prototypes](https://github.com/reitzig/2012_auto-parallel-dynprog_prototypes)
   and one for the
     [Scala compiler plugin](https://github.com/reitzig/2012_auto-parallel-dynprog_compiler).
     
   
   You have a machine on which you think the algorithms would behave differently?
   Please [run your own benchmarks](https://github.com/reitzig/2012_auto-parallel-dynprog_compiler) 
   and let us know!
  
   <h4>Download</h4>
    
   There are multiple versions of the thesis.
   All differences are cosmetic in nature; there are none in the content.
     
   <table style="border:none;background:none;margin: 2ex auto 2ex 0;border-spacing:0 2ex;">
   <tbody>
   <tr>
   <td style="border:none;text-align:center;">
     <a href="/assets/pdf/auto-parallel-dynprog_screencolor.pdf">
       <img class="framed" style="margin:0 1ex;width:200px;"
            title="Download colored screen version" 
            alt="Download colored screen version"
            src="/assets/posts_img/math_screencolor.png">
       <br>
       Screen version, colored
     </a>
   </td>
   <td style="border:none;text-align:center;">
     <a href="/assets/pdf/auto-parallel-dynprog_printcolor.pdf">
       <img class="framed" style="margin:0 1ex;width:200px;"
            title="Download colored print version"
            alt="Download colored print version" 
            src="/assets/posts_img/math_printcolor.png">
       <br>
       Print version, colored
     </a>
   </td>
   </tr>
   <tr>
   <td style="border:none;text-align:center;">
     <a href="/assets/pdf/auto-parallel-dynprog_screengray.pdf">
       <img class="framed" style="margin:0 1ex;width:200px;"
            title="Download colorless screen version"
            alt="Download colorless screen version"
            src="/assets/posts_img/math_screengray.png">
       <br>
       Screen version, grayscale
     </a>
   </td>
   <td style="border:none;text-align:center;">
     <a href="/assets/pdf/auto-parallel-dynprog_printgray.pdf">
       <img class="framed" style="margin:0 1ex;width:200px;"
            title="Download colorless print version" 
            alt="Download colorless print version"
            src="/assets/posts_img/math_printgray.png">
       <br>
       Print version, grayscale
     </a>
   </td>
   </tr>
   </tbody>
   </table>
   
   * Print versions use a two-sided layout whereas screen versions have
     highlighted links within the document.
      
   * The grayscale versions have different graphics and color settings in order
     to improve readability on monochromatic displays, printed in grayscale and 
     for individuals with color-perception disabilities.
  },
  code = {https://github.com/search?q=user:reitzig+2012_auto-parallel-dynprog},
  talk = {http://www.slideshare.net/rreitzig/parallelising-dynamic-programming}
}

@ARTICLE{NWH+2010,
  author = {Markus E. Nebel and Sebastian Wild and Michael Holzhauser and Lars
  Hüttenberger and Raphael Reitzig and Matthias Sperber and Thorsten Stoeck},
  title = {JAguc -- a software package for environmental diversity analyses},
  journal = {Journal of Bioinformatics and Computational Biology},
  year = {2011},
  volume = {9},
  pages = {749--773},
  number = {6},
  month = {December},
  comment = {03-02},
  doi = {10.1142/S0219720011005781},
  institution = {University of Kaiserslautern},
  url = {http://wwwagak.cs.uni-kl.de/home/forschung/jaguc},
  pdf = {http://wwwagak.cs.uni-kl.de/home/forschung/veroeffentlichungen/Papers/JAguc----a-software-package-for-environmental-diversity-analyses/},
  abstract = {**Background**
  The study of microbial diversity and community structures heavily relies on the analyses
  of sequence data, predominantly taxonomic marker genes like the small subunit of the
  ribosomal RNA (SSU rRNA) amplified from environmental samples. Until recently, the
  “gold standard” for this strategy was the cloning and Sanger sequencing of amplified
  target genes, usually restricted to a few hundred sequences per sample due to relatively
  high costs and labor intensity. The recent introduction of massive parallel tag sequencing
  strategies like pyrosequencing (454 sequencing) has opened a new window into microbial
  biodiversity research. Due to its swift nature and relatively low expense, this strategy
  produces millions of environmental SSU rDNA sequences granting the opportunity to
  gain deep insights into the true diversity and complexity of microbial communities. The
  bottleneck, however, is the computational processing of these massive sequence data,
  without which, biologists are hardly able to exploit the full information included in
  these sequence data.
  
  **Results**
  The freely available standalone software package JAguc implements a broad regime of
  different functions, allowing for efficient and convenient processing of a huge number
  of sequence tags, including importing custom-made reference data bases for basic local
  alignment searches, user-defined quality and search filters for analyses of specific sets of
  sequences, pairwise alignment-based sequence similarity calculations and clustering as
  well as sampling saturation and rank abundance analyses. In initial applications, JAguc
  successfully analyzed hundreds of thousands of sequence data (eukaryote SSU rRNA
  genes) from aquatic samples and also was applied for quality assessments of different
  pyrosequencing platforms.
  
  **Conclusions**
  The new program package JAguc is a tool that bridges the gap between computational
  and biological sciences. It enables biologists to process large sequence data sets in order
  to infer biological meaning from hundreds of thousands of raw sequence data. JAguc
  offers advantages over available tools which are further discussed in this manuscript.
  While providing a highly efficient implementation of its functionality adjusted to typical
  molecular environmental diversity analyses, JAguc is not restricted to the analyses of
  environmental pyrosequencing data but is applicable to a broad array of further applications,
  including motif searches or (meta)transcriptomes.
  }
}

@misc{Reitzig2009,
  author = {Raphael Reitzig},
  title  = {Ambiguity Analysis of RNA Secondary Structure Prediction Grammars},
  year   = {2009},
  month  = {September},
  howpublished = {Bachelor's thesis},
  school = {University of Kaiserslautern},
  pdf    = {/assets/pdf/ambiguity-analysis-of-RNA-grammars.pdf},
  abstract = {Dowell and Eddy (2004) presented several context free grammars for 
    RNA secondary structure prediction. Some of them are claimed to be unambiguous 
    with respect to secondary structures. Although this property is crucial for the 
    correctness of prediction algorithms using those grammars, it is only shown 
    empirically, but not formally proven. This gap is filled in the work at hand.
  }
}
